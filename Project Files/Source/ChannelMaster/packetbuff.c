/*  packetbuff.c

This file is part of a program that implements a Software-Defined Radio.

Copyright (C) 2019 Warren Pratt, NR0V

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

The author can be reached by email at  

warren@pratt.one

*/

// DDC-SPECIFIC DESCRIPTION OF OPERATION:
// 
// When the DFC down-conversion executes, it will suddenly generate data for a large
// number of DDC packets.  The data for these DDC packets is buffered by the 
// 'packetbuff.c' code.  Note that the DDC down-conversion code only provides
// the ADC number, the DDC number, and the data to the 'packetbuff.c' code.  The 
// 'packetbuff.c' code fills out the remainder of the complete packet, just like the
// packet that would be generated by firmware and received from a network interface.
//
// When the 'packetbuff' code has packets to deliver for downstream processing, it
// calls ProcessPacket(...) wtih one packet at a time.  It provides the port number
// and the packet, as would be provided from a network interface.
//
// When the DFC code has some data, it calls the function 'ddcfun(...)' to provide it.
// The number of samples provided per call is 'DDC_OUTSIZE' and is
// the amount of data contained in one network packet.  
// Note that several such calls may be made in rapid-fire succession.
//
// OTHER TYPES OF PACKETS (E.G., mic PACKETS) - DESCRIPTION OF OPERATION:
//
// The packets stored and retrieved here are full-size, complete, 1444-byte packets.
// Therefore, there's no reason that 'mic', 'C&C', whatever types of packets can't
// also be inserted here.  They will end up being retrieved by 'ProcessPacket(...)'
// which knows how to process all these types of packets.
//
// To insert, for example, a 'mic' packet, a new function, 'micfun(...)' will need
// to be created.  It will build the packet like 'ddcfun(...)' builds DDC packets
// and will then call forward_packet(...) to have the packet inserted in the queue.
//
// BUILD ORDER & POINTER STUFFING IMPLICATIONS:
//
// * 'packetbuff.c' and 'packetbuff.h' are in the ChannelMaster.  The function
//   'ProcessPacket(...)' and its caller are therefore in the same project and
//   the linker can set up the call at build-time.
// * The 'dfc' project will be built before the 'ChannelMaster'.  Therefore, a
//   pointer for any call from the 'dfc' project to the 'ChannelMaster' must be
//   stuffed at run time.  'ddcfun(...)' is such a function.  At run-time, the
//   'ChannelMaster' must call the 'dfc' project and give it a pointer to 
//   'ddcfun(...)'.  A function to call is provided in the 'dfc' project and can
//   be linked at ChannelMaster build-time.
// 
#include "packetbuff.h"

__declspec (dllexport) void ProcessPacket(int port, unsigned char* packet);	// in network.c
__declspec (dllexport) void TransferDDCcallback (int adc, void (__stdcall *ddcfun)(int adc, int ddc, unsigned char* packet_data));	// in rxloop.cu

// Start a thread to take packets out of the queue and transfer them
// to 'ProcessPacket(...)'.  This activity is performed in the function
// 'GetNextDFCPacket(...)'.
void GetNextDFCPacket ();
void start_pbuffthread ()
{
	HANDLE handle = (HANDLE) _beginthread(GetNextDFCPacket, 0, (void *)0);
	SetThreadPriority(handle, THREAD_PRIORITY_HIGHEST);
}

// 'create_packetbuff(...) must be called at initialization to allocate storage
// and set up the packet buffer.
void send_function_pointers();
void create_packetbuff (int max_packets, int packet_size)
// max_packets:  maximum number of packets that can be buffered in this software
// packet_size:  maximum packet size in bytes; per protocol, set to 1444 which
//   includes the sequence number
{
	PACKETBUFF a = (PACKETBUFF) calloc (1, sizeof (packetbuff));
	int i;
	a-> max_packets = max_packets;
	a->packet_size = packet_size;
	a->in_index = 0;
	a->out_index = 0;
	a->port_in_index = 0;
	a->port_out_index = 0;
	a->buff_size = a->max_packets * a->packet_size;
	a->packet_buffer = (unsigned char *) calloc (a->buff_size, sizeof (char));
	a->port_buffer = (int *) calloc (a->max_packets, sizeof (int));
	InitializeCriticalSectionAndSpinCount (&a->cs_input_lock, 2500);
	a->sem_num_packets = CreateSemaphoreW (0, 0, a->max_packets, 0);
	start_pbuffthread();
	pbuff = a;
	// specifically for DDCs
	// allocate packet storage for each ddc
	a->ddcpacket = (unsigned char **) calloc (NUMADC * NUMDDC, sizeof (unsigned char *));
	for (i = 0; i < NUMADC * NUMDDC; i++)
		a->ddcpacket[i] = (unsigned char *) calloc (1, a->packet_size * sizeof (unsigned char));
	// allocate sequence number storage for each ddc
	a->ddcseq = (unsigned int *) calloc (NUMADC * NUMDDC, sizeof (int));
	send_function_pointers();
}

void destroy_packetbuff (PACKETBUFF a)
{
	CloseHandle (a->sem_num_packets);
	DeleteCriticalSection (&a->cs_input_lock);
	free (a->port_buffer);
	free (a->packet_buffer);
	free (a);
}

void GetNextDFCPacket (void* pargs)
{
	PACKETBUFF a = pbuff;
	int port;
	unsigned char* packet;
	while (1)
	{
		// wait until a packet is available
		WaitForSingleObject(a->sem_num_packets,INFINITE);
		// get the address of the packet payload
		packet = &a->packet_buffer[a->out_index];
		// get the packet port number
		port = a->port_buffer[a->port_out_index];
		// call ProcessPacket with port and payload address
		ProcessPacket(port, packet);
		// increment port storage address and payload address
		if (++a->port_out_index >= a->max_packets) a->port_out_index = 0;
		if ((a->out_index += a->packet_size) >= a->buff_size) a->out_index = 0;
		return;
	}
}

void forward_packet (int port, unsigned char* packet)
{
	PACKETBUFF a = pbuff;
	// the critical_section limits access to one thread at a time
	EnterCriticalSection (&a->cs_input_lock);
	// store the port number in the port_number buffer
	a->port_buffer[a->port_in_index] = port;
	// store the packet data
	memcpy (&a->packet_buffer[a->in_index], packet, a->packet_size * sizeof (unsigned char));
	if (++a->port_in_index >= a->max_packets) a->port_in_index = 0;
	// Increment in_index.  This assumes that buff_size is an integral multiple of packet_size!
	if ((a->in_index += a->packet_size) >= a->buff_size) a->in_index = 0;
	// increment the (semaphore) count of available packets
	ReleaseSemaphore (a->sem_num_packets, 1, 0);
	LeaveCriticalSection (&a->cs_input_lock);
}

void __stdcall ddcfun (int adc, int ddc, unsigned char* packet_data)
{
	// ddcfun(...) is called from rxloop.cu each time there is a packet of data to process.
	// It calls forward_packet to insert the port number in the port_number buffer, to insert
	// the data in the packet data buffer, and to increment the packet semaphore count.
	//
	// Note that 'ddcpacket' is set up with separate packet storage for each ddc which means
	// that data for each ddc can be provided on a separate thread if desired.
	PACKETBUFF a = pbuff;
	int ddcnum, port;
	const int ddc_baseport = 1035;
	unsigned int seqnum;
    unsigned char* seqbytes = (unsigned char *)&seqnum;
	
	// calculate port number
	ddcnum = adc * NUMDDC + ddc;
	port = ddc_baseport + ddcnum;

	// prepare packet data
	// initialize packet as zero so that unfilled entries will be zero
	memset (a->ddcpacket[ddcnum], 0, a->packet_size * sizeof (unsigned char));
	// insert the sequence number, doing the big/little endian conversion
	seqnum = a->ddcseq[ddcnum]++;
	a->ddcpacket[ddcnum][0] = seqbytes[3];
	a->ddcpacket[ddcnum][1] = seqbytes[2];
	a->ddcpacket[ddcnum][2] = seqbytes[1];
	a->ddcpacket[ddcnum][3] = seqbytes[0];
	// copy in the data, beginning at byte 16
	memcpy (&a->ddcpacket[ddcnum][16], packet_data, 1428);
	// put the packet into the queue, ready to be retrieved for downstream processing
	forward_packet (port, a->ddcpacket[ddcnum]);
}

void send_function_pointers ()
{
	int i;
	// send pointers for 'ddcfun'
	// we are using a single 'ddcfun' instance for all ADCs; therefore, it will be sent
	// for each ADC
	for (i = 0; i < NUMADC; i++)
		TransferDDCcallback (i, ddcfun);
}
